*usr_24.txt*	Vim version 7.0 대상.  새로고침: 2006 Apr 24

		      VIM 사용설명서 - Bram Moolenaar 저
                         정지용 역

			       빠르게 입력하기


빔은 문서를 작성할 때 타이핑 수를 줄이고, 실수를 막기 위한 다양한 도구를
제공합니다.  이미 입력한 단어를 반복해서 입력하는 경우에는 입력 상태 자동
완성을 사용하십시오.  긴 단어들은 약어를 만들어 입력하십시오.  키보드에는 없는
문자들을 입력할 수도 있습니다.

|24.1|	틀린 내용 고치기
|24.2|	괄호 짝 찾기
|24.3|	자동 완성
|24.4|	반복 입력
|24.5|	다른 줄에서 복사해오기
|24.6|	레지스터 내용 입력하기
|24.7|	약어
|24.8|	특수문자 입력
|24.9|	다이그래프(Digraph)
|24.10|	보통 상태 명령

다음 장: |usr_25.txt|  형식에 맞추어 편집하기
이전 장: |usr_23.txt|  특별한 파일 편집하기
   차례: |usr_toc.txt|

==============================================================================
*24.1*	틀린 내용 고치기

<BS> 키는 앞서 말했듯이, 커서 바로 앞의 글자를 지웁니다.  <Del> 키는 커서가
위치해있는(혹은, 바로 다음의) 글자를 지웁니다.
   만약 단어 전체를 잘못 입력했다면, CTRL-W를 사용하십시오:

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

내용이 완전히 꼬여서 줄 전체를 다시 입력하고 싶다면, CTRL-U로 전체를
지우십시오.  커서 뒤의 내용과 들여쓰기는 지워지지 않습니다.  공백이 아닌 첫
글자부터 커서까지의 내용만 지워집니다.  다음 예에서 "fallen"의 "f"에 커서를
두고 CTRL-U를 누르면 다음과 같이 됩니다:

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

몇 단어 전에 잘못 입력한 내용이 있어서, 커서를 옮긴 후 고쳐야한다고 합시다.
예를 들어 다음과 같이 입력했다고 합시다:

	The horse had follen to the ground ~

"follen"을 "fallen"으로 고쳐야합니다.  커서가 맨 뒤에있다고 할 때, 다음을
입력하면 됩니다:

					<Esc>4blraA

<	입력 상태 벗어나기		<Esc>
	네 단어 앞으로			     4b
	오른쪽으로 한 칸 움직여 "o" 위로       l
	"a"로 바꿈				ra
	입력 상태로 돌아감			  A

다음 방법으로 해도 됩니다: >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	네 단어 앞으로		     <C-Left><C-Left><C-Left><C-Left>
	오른쪽으로 한 칸 움직여 "o" 위로	<Right>
	"o"를 지움				       <Del>
	"a"를 입력					    a
	줄의 끝으로 이동				     <End>

이 방법에서는 입력 상태를 유지한 채, 특수키들을 사용해서 움직입니다.  상태가
따로 없는 일반적인 편집기들과 마찬가지입니다.  외우기는 쉽지만, 더 오래
걸립니다 (손을 일반키 자판에서 화살표키로 옮겨야하는 데다가, 키보드를 보지
않고 <End> 키를 누르기는 쉽지 않습니다).
   이 특수키들은 입력 상태를 벗어나지 않는 매핑을 만들 때 유용합니다.  이 때는
타이핑을 하는 데 걸리는 시간이 별로 문제되지 않을테니까요.
   입력 상태에서 사용할 수 있는 키들은 다음과 같습니다:

	<C-Home>	파일의 시작으로
	<PageUp>	한 화면 위로
	<Home>		줄의 시작으로
	<S-Left>	한 단어 왼쪽으로
	<C-Left>	한 단어 왼쪽으로
	<S-Right>	한 단어 오른쪽으로
	<C-Right>	한 단어 오른쪽으로
	<End>		줄의 끝으로
	<PageDown>	한 화면 아래로
	<C-End>		파일의 끝으로

여기에 언급되지 않은 명령이 몇 가지 더 있는데, |ins-special-special|에서 볼 수
있습니다.

==============================================================================
*24.2*	괄호 짝 찾기

) 를 입력할 때, 대응되는 ( 를 알려줄 수 있다면 좋을 것입니다.  빔에서는 다음
명령을 사용하면 됩니다: >

	:set showmatch

"(예제)"를 타이핑 할 때, ) 를 입력하는 순간, 잠깐 커서가 대응되는 ( 로
옮겨졌다가 0.5초 쯤 후에 다시 원래 위치로 돌아옵니다.
   대응되는 ( 가 없는 경우에는, 경고음을 내서 어딘가에 ( 를 빼먹었거나, ) 를
너무 많이 입력했다고 알려줍니다.
   [] 나 {} 쌍도 대응되는 것을 보여줍니다.  대응되는 괄호가 보여지는 동안
기다릴 필요는 없습니다.  다음 문자가 입력되자마자 커서가 원래 위치로 옮겨지고
입력이 계속 처리됩니다.
   'matchtime'(대응시간) 설정으로 빔이 괄호쌍을 보여주는 시간을 조절할 수
있습니다.  1.5초간 보여주게 하려면: >

	:set matchtime=15

시간은 10분의 1초 단위로 지정합니다.

==============================================================================
*24.3*	자동 완성

입력 도중에 단어를 완성시킬 수 있습니다.  단어의 앞부분을 입력하다가 CTRL-P 를
누르면 됩니다.  나머지 부분은 빔이 추측하여 채우게 됩니다.
   예를 들어, C 프로그래밍 중 다음과 같은 내용을 넣고 싶다고 합시다 :

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

먼저 다음 내용을 입력하십시오:

	total = ch_array[0] + ch_ ~

이 상황에서, CTRL-P 명령으로 단어를 완성시켜봅시다.  빔은 커서의 앞쪽에 위치한
문자들로 시작하는 단어를 찾습니다.  이 경우에는 "ch_" 이므로, ch_array 라는
단어가 해당됩니다.  따라서 CTRL-P 를 입력한 결과는 다음과 같습니다:

	total = ch_array[0] + ch_array ~

다음과 같이 몇 자 더 입력했다고 합시다 (맨 마지막에 스페이스가 있습니다):

	total = ch_array[0] + ch_array[1] +  ~

CTRL-P 를 누르면 빔은 커서 앞의 단어를 완성시키기에 적절한 단어를 찾습니다.
커서 앞에는 공백만 있을 뿐 아무 내용도 없기 때문에, 커서 이전(backward)의 첫
번째 단어인 "ch_array"를 찾게 됩니다.  CTRL-P 를 한 번 더 누르면 다음 대응되는
단어인 "total"을 보여줍니다.  CTRL-P 를 더 누르면 그 다음을 계속 찾게 됩니다.
위 내용 밖에 없으면, 추천할 단어가 바닥났으므로 원래의 내용으로 돌아오게
됩니다.  이 경우에는 그냥 아무것도 없는 상태가 됩니다.  네 번째 CTRL-P 로는
추천 단어 찾기가 다시 시작되고, "ch_array"가 다시 나옵니다.

단어 완성 후보를 현재 커서 위치 이후(forward)에서 먼저 찾으려면, CTRL-N 을
사용하십시오.  파일의 끝을 만나면, 파일의 맨 처음으로 돌아가서 계속 찾기
때문에, CTRL-N 과 CTRL-P 는 같은 단어들을 반대의 순서로 보여주게 됩니다.
힌트: CTRL-N 은 이후(Next) 찾기이고, CTRL-P 는 이전(Previous) 찾기입니다.

빔은 자동으로 단어를 완성하기 위해, 많은 곳을 찾습니다.  기본적으로 다음
내용들을 찾습니다:

	1. 현재 파일
	2. 다른 창의 파일
	3. 다른 로딩된 파일 (숨겨진 버퍼)
	4. 로딩되지 않은 파일 (비활성 버퍼)
	5. 태그 파일
	6. 현재 파일에 인클루드(#include) 된 파일


설정

탐색 순서는 'complete'(자동완성) 설정으로 바꿀 수 있습니다.

'ignorecase'(대소문자무시) 설정이 켜지면 찾을 때 대소문자 차이가 무시됩니다.

자동 완성과 관련된 설정 중 'infercase'(대소문자추론)는 대소문자를 무시하고 단어를 찾기는
하지만 ('ignorecase' 설정이 켜져있어야 합니다), 현재 입력한 내용의 대소문자
여부를 유지해야할 때 유용합니다.  예를 들어 "For"를 입력하고, 빔이
"fortunately"를 찾았을 때, "Fortunately"로 자동완성 됩니다.


특정한 내용으로 자동완성 하기

어떤 내용을 입력할 지 이미 알고 있다면, 특정한 내용의 경우는 다음 명령을
사용하여 완성할 수도 있습니다:

	CTRL-X CTRL-F		파일명
	CTRL-X CTRL-L		줄 전체
	CTRL-X CTRL-D		매크로 정의 (인클루드(#include) 된 파일 포함)
	CTRL-X CTRL-I		현재 파일과 인클루드 된 파일
	CTRL-X CTRL-K		사전에서 찾기
	CTRL-X CTRL-T		시소러스에서 찾기
	CTRL-X CTRL-]		태그
	CTRL-X CTRL-V		빔 명령줄

위 명령 입력 후에는 CTRL-N 으로 다음 후보로, CTRL-P 로 이전 후보로 이동할 수
있습니다.
   명령에 대한 더 자세한 정보는 |ins-completion|을 참고하십시오.


파일명 자동완성

예를 들어 CTRL-X CTRL-F 를 봅시다.  이 명령은 파일명으로 완성시켜줍니다.  현재
디렉토리를 찾아서 현재 커서 앞의 문자열과 일치하는 것을 보여줍니다.
   예를 들어, 현재 디렉토리에 다음과 같은 파일들이 있다고 합시다:

	main.c  sub_count.c  sub_done.c  sub_exit.c

입력 상태로 들어가서 다음 내용을 입력하십시오:

	종료 코드는 다음 파일에 있습니다: sub ~

이 상태에서, CTRL-X CTRL-F 를 입력하십시오.  빔이 현재 디렉토리를 찾아서,
"sub"로 시작하는 단어로 완성시킬 것입니다.  첫번째 후보는 sub_count.c 입니다.
이것이 아니라면, CTRL-N 으로 다음 파일로 넘어갑니다.  이번 후보는 sub_done.c
입니다.  CTRL-N 을 또 누르면 sub_exit.c 가 됩니다.  결과는 다음과 같습니다.

	종료 코드는 다음 파일에 있습니다: sub_exit.c ~

파일명이 / (유닉스) 나 C:\ (MS-윈도우) 로 시작하는 경우에는 파일시스템의 모든
파일을 찾을 수 있습니다.  예를 들어, "/u"를 입력하고 CTRL-X CTRL-F 를 하면,
"/usr" 가 될 것입니다 (유닉스):

	파일은 다음 위치에 있습니다 /usr/ ~

다시 CTRL-N 을 누르면 "/u"로 돌아갑니다. "/usr/" 상태에서 한 디렉토리 더
안으로 들어가려면, CTRL-X CTRL-F 를 다시 누르면 됩니다:

	파일은 다음 위치에 있습니다 /usr/X11R6/ ~

물론, 실제 동작은 현재 파일 시스템의 상태에 따라 다릅니다.  완성 후보들은
알파벳 순으로 정렬됩니다.


프로그램 소스 코드에서의 자동완성

소스코드 파일은 보통 그 구조가 정해져 있으므로, 좀 더 머리를 쓰면 훨씬
훌륭하게 자동완성을 할 수 있습니다.  빔에는 옴니(Omni) 자동완성이란 기능이
있습니다.  다른 에디터에서는 인텔리센스(intellisense - 상표권이
걸려있습니다)라고도 부릅니다.

옴니 자동완성의 키는 CTRL-X CTRL-O 입니다.  물론 O는 옴니(Omni)의 O이므로
외우기 쉽습니다.  C 프로그램 소스를 편집하는 예를 보겠습니다:

	{ ~
	    struct foo *p; ~
	    p-> ~

커서가 "p->" 다음에 있을 때, CTRL-X CTRL-O 를 눌러봅시다.  빔은 "struct foo"에
속한 단어들로 후보 목록을 만듭니다.  CTRL-P 를 눌렀을 때처럼 모든 단어가
후보가 되는 게 아니라, 현재 상황에 적합한 "struct foo"의 멤버들만 후보가
된다는 점이 다릅니다.

옴니 자동완성이 동작하기 위해서는 미리 설정을 좀 해야합니다.  C 코드를
작성하는 경우, 태그파일을 만들고 'tags'(태그) 설정을 해놓아야 합니다.  자세한 설명은
|ft-c-omni|를 참고하십시오.  다른 종류의 파일도 비슷한 일을 해야하는데,
|compl-omni-filetypes|를 참고하십시오.  아직은 잘 알려진 몇몇 종류의
파일에서만 동작합니다.  현재 동작 중인지 여부를 확인하려면
'omnifunc'(옴니함수) 설정값을 확인하십시오.

==============================================================================
*24.4*	반복 입력

CTRL-A 를 누르면, 지난 입력 상태 때 입력했었던 내용을 다시 입력합니다.
   예를 들어, 다음 내용으로 시작하는 파일이 있다고 합시다.

	"file.h" ~
	/* main 프로그램 코드 */ ~

첫 번째 줄의 앞에 "#include "를 추가했습니다:

	#include "file.h" ~
	/* main 프로그램 코드 */ ~

"j^" 를 입력하여 다음 줄의 맨 앞으로 이동합니다.  또 "#include" 로 시작하는
줄을 입력하려면 :

	i CTRL-A

결과는 다음과 같습니다:

	#include "file.h" ~
	#include /* main 프로그램 코드 */ ~

CTRL-A 를 누르면 지난 입력 상태 때 입력한 내용이 입력되므로, 위와 같이
"#include "가 들어갔습니다.  "main.h"<Enter> 를 입력하여 줄을 완성합시다:


	#include "file.h" ~
	#include "main.h" ~
	/* main 프로그램 코드 */ ~

CTRL-@ 명령은 CTRL-A 역할을 한 후, 입력 상태를 빠져나갑니다.  똑같은 내용을
계속 입력해야할 때 사용하면 좋습니다.

==============================================================================
*24.5*	다른 줄에서 복사해오기

CTRL-Y 명령은 커서 바로 위의 글자를 입력합니다.  앞 줄의 내용을 복사할 때
유용합니다.  예를 들어, 다음과 같은 C 코드가 있다고 합시다:

	b_array[i]->s_next = a_array[i]->s_next; ~

"s_prev"만 "s_next"로 바꾸며 같은 내용을 또 입력하고 싶다고 합시다.
새 줄을 시작하고, CTRL-Y 를 14번 눌러 "next"의 "n"앞까지 옵시다:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~

"prev"를 직접 입력합시다:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

다시 CTRL-Y 를 "next"가 나올 때까지 누릅시다:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~

"prev;"를 입력해서 끝냅시다.

반대로 CTRL-E 는 커서 밑의 문자를 CTRL-Y 와 유사한 방법으로 입력합니다.

==============================================================================
*24.6*	레지스터 내용 입력하기

CTRL-R {레지스터} 명령은 레지스터의 내용을 입력합니다.  긴 단어를 입력할 때
유용합니다.  예를 들어, 다음 내용을 입력한다고 합시다:

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

함수명은 다른 파일에서 정의되었다고 합시다.  그 파일에서 함수명 위로 커서를
옮긴 후, 레지스터 v로 복사해넣읍시다: >

	"vyiw

"v 는 레지스터 지정이고, "yiw"는 복사하기(yank)-안쪽의(inner)-단어(word) 입니다.
내용을 입력할 파일로 가서, 줄의 앞부분을 직접 입력합시다:

	r = ~

이제 CTRL-R v 를 써서 함수명을 입력합니다:

	r = VeryLongFunction ~

함수명 사이의 내용은 직접 바로 입력하면 되고, 함수명은 CTRL-R v 를 두 번 더
써서 입력합니다.
   자동완성을 써서 입력할 수도 있습니다.  하지만 같은 문자로 시작하는 단어들이
많은 경우에는 레지스터를 쓰는 쪽이 더 효율적입니다.

만약 레지스터에 <BS> 같은 특수 문자가 들어있다면, 그 문자가 키보드에서 눌린
것처럼 해석되어 동작하게 됩니다.  이 것을 막으려면 (진짜로 문서에 <BS> 문자를
넣으려면) CTRL-R CTRL-R {레지스터} 명령을 사용하십시오.

==============================================================================
*24.7*	약어

약어(abbreviation)란 원래의 긴 단어를 간략하게 표시한 것입니다.  예를 들어,
일반적으로 "ad"는 "advertisement"를 의미합니다.  빔에는 약어를 입력하면
자동으로 긴 표현으로 확장해주는 기능이 있습니다.
   "ad"를 입력하면 자동으로 "advertisement"로 확장되도록 하려면, 다음 명령을
사용하십시오: >

	:iabbrev ad advertisement

이제 "ad"만 입력하면, 자동으로 "advertisement"가 확장되어 들어갑니다.  이
확장은 단어의 일부가 될 수 없는 문자 - 예를 들어 스페이스 - 가 들어올 때
일어납니다:

	입력된 내용		화면에 나타나는 내용
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

"ad"만 입력해서는 확장이 일어나지 않습니다.  이는 "add" 같은 단어를 입력할 수
있도록, 다른 단어의 일부인 경우는 확장이 일어나지 않게 하기 위함입니다.  오직
단어 통째에 대해서만 약어인지 여부를 확인합니다.


어구의 약어인 경우

약어가 단어 하나가 아니라 여러 단어로 이루어진 어구를 가리키도록 할 수도
있습니다.  예를 들어, "JB"를 "Jack Benny"로 정의하려면 다음 명령을
사용하십시오: >

	:iabbrev JB Jack Benny

저는 프로그래밍을 위해 다음과 같은 특이한 약어를 사용합니다: >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

이 약어들은 주석 상자를 만들기 위해서 씁니다.  윗 줄을 그리는 #b 로 주석
상자를 열고, 주석 내용을 모두 쓴 다음, #e 로 아랫 줄을 그려서 주석을
마무리하면 됩니다.
   특이하게 #e 약어는 스페이스로 시작하고 있습니다.  즉, 첫 두 문자가
스페이스와 별입니다.  일반적으로 약어와 긴 표현 간의 공백은 무시됩니다.
따라서 공백을 표시하기 위해 <, S, p, a, c, e, > 라고 명확하게 써 준 것입니다.

	Note:
	":iabbrev" 도 매 번 입력하기는 꽤 긴 명령입니다.  ":iab" 만 써도
	됩니다.  약어 명령의 약어인 셈이지요.


입력 오류 자동 수정

키보드를 치다보면 같은 입력 실수를 계속 하게되는 경우가 있습니다.  예를 들어,
"the"를 쳐야하는데, "teh"라고 치는 경우가 많습니다.  이 경우 다음과 같은
약어로 자동으로 고쳐지도록 할 수 있습니다: >

	:abbreviate teh the

이런 실수들을 모두 등록해 놓으면 됩니다.  만날 틀리는 단어를 발견할 때마다
등록해주면 되겠습니다.


약어 목록 표시하기

":abbreviate" 명령은 약어의 목록을 보여줍니다:

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

줄 맨 앞의 "i"는 입력(insert) 상태를 나타냅니다.  이 약어는 입력 상태에서만
유효합니다.  "i" 외에도 다음 문자들이 올 수 있습니다:

	c	명령줄 상태				:cabbrev
	!	입력 상태와 명령줄 상태			:abbreviate

일반적으로 명령줄 상태에서는 약어가 많이 쓰이지 않으므로, 대부분 ":iabbrev"
명령을 사용하게 될 것입니다.  따라서 다음과 같은 명령을 사용할 때는 "ad"가
확장되지 않습니다: >

	:edit ad


약어 삭제하기

약어를 삭제하려면, ":unabbreviate" 명령을 사용합니다.  다음과 같은 약어가
있다고 합시다 >

	:abbreviate @f fresh

다음 명령으로 약어를 지울 수 있습니다 >

	:unabbreviate @f

명령을 입력하다보면, @f가 "fresh"로 확장되었을 것입니다.  하지만, 어쨌든 빔이
잘 인식해서 지울테니 걱정하지 않아도 됩니다 (단, "fresh"가 다른 단어의
약어였다면 엉뚱한 것이 지워지겠지만, 이럴 일은 거의 없을 것입니다).
   모든 약어를 지우려면: >

	:abclear

":unabbreviate"와 ":abclear"의 입력 상태 한정판(":iunabbreviate"와
":iabclear")과 명령줄 상태 한정판(":cunabbreviate"와 ":cabclear")도 있습니다.


약어가 다시 매핑 되는 경우

약어를 정의할 때 주의할 점이 있습니다: 확장된 문자열이 매핑 되지 않아야한다는
것입니다.  예를 들어: >

	:abbreviate @a adder
	:imap dd disk-door

이 상태에서 @a 를 입력하면, "adisk-doorer"가 나타날 것입니다.  물론 이 것을
의도한 것은 아닙니다만.  이렇게 약어가 다시 매핑되는 경우를 피하려면,
":noreabbrev" 명령을 사용하십시오.  ":abbreviate"와 동일하지만, 확장된 문자열이 
다시 매핑되는 것을 막아줍니다: >

	:noreabbrev @a adder

다행히 약어가 확장된 결과가 다시 매핑되는 경우는 그리 많지 않습니다.

==============================================================================
*24.8*	특수문자 입력

다음 문자를 문자 그대로 문서에 입력하려면, CTRL-V 명령을 사용하면 됩니다.  즉,
다음 문자의 특별한 기능이 무시된다는 의미입니다.  예를 들어: >

	CTRL-V <Esc>

위 명령은 이스케이프 문자를 삽입합니다.  따라서 입력 상태에서 빠져나가지
않습니다.  (CTRL-V 다음에 스페이스를 누르지 마십시오.  읽기 쉽도록 띄어놓은 것
뿐입니다).

	Note:
	MS-윈도우에서는 CTRL-V가 붙여넣기에 사용됩니다.  이 때는 CTRL-V 대신
	CTRL-Q를 사용하십시오.  반대로 유닉스에서는 종종 CTRL-Q가 다른 용도로
	사용되므로, CTRL-Q가 동작하지 않습니다.

{숫자} 에 해당하는 문자를 입력하려면, CTRL-V {숫자} 명령을 사용하십시오.  예를
들어, 127에 해당하는 문자인 <Del> 문자(<Del> 키가 항상 <Del> 문자를 나타내지는
않습니다!)를 입력하려면: >

	CTRL-V 127

이 방법으로 255까지의 문자를 입력할 수 있습니다.  숫자가 두 자리 이하일
경우에는, 숫자가 아닌 문자를 입력하면 명령이 끝납니다.  숫자가 아닌 문자를
입력하지 않으려면, 숫자 앞에 0을 붙여서 세 자리로 만들어주면 됩니다.
   다음의 명령들은 모두 <Tab> 문자와 점을 입력합니다:

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

숫자를 16진수로 입력하려면, CTRL-V 다음에 "x"를 입력하면 됩니다: >

	CTRL-V x7f

역시 255(CTRL-V xff)까지의 문자를 입력할 수 있습니다.  숫자 앞에 "o"를 붙여서
8진수로 입력할 수도 있습니다.  그리고, 16 비트 문자나 32비트 문자를 입력하기
위한 방법도 있습니다 (예를 들어, 유니코드를 입력할 때 사용할 수 있습니다):

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	다이그래프(Digraph)

가끔 키보드에 없는 문자를 입력해야 할 때가 있습니다.  저작권을 나타내는 ©
문자가 좋은 예입니다.  빔에서 이런 문자들을 입력하려면, 두 문자로 한 문자를
표현하는 다이그래프(digraph)를 사용하면 됩니다.  예를 들어 © 를 입력하려면
다음과 같이 세 개의 키를 눌러야 합니다: >

	CTRL-K Co

다이그래프로 입력할 수 있는 문자를 보려면, 다음 명령을 사용하십시오: >

	:digraphs

다이그래프 문자표가 나옵니다.  다음은 그 중 세 줄만 뽑아본 것입니다:

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

예를 들어 위 표를 보고, £ 문자를 입력하려면 CTRL-K Pd 를 누르면 된다고 알 수
있습니다.  이 문자는 10진수로 163에 해당합니다.
   Pd 는 파운드(Pound)를 줄인 것입니다.  대부분의 다이그래프는 실제로 표시되는
문자를 쉽게 짐작할 수 있도록 정해졌습니다.  위 표를 쭉 살펴보면 이해가 가실
것입니다.
   겹치는 다이그래프가 없다면, 첫 번째와 두 번째 문자를 바꿔서 눌러도
괜찮습니다.  즉, CTRL-K dP 에 해당하는 게 없다면, "Pd"에 해당되는 문자를
보여줍니다. (역주: CTRL-K dP 에 해당하는 문자가 있는 경우도 있습니다.)

	Note:
	다이그래프는 빔이 인식하는 문자셋에 따라 달라집니다.  
	MS-DOS에서의 다이그래프는 윈도우에서와 다를 수도 있습니다.  따라서
	현재 어떤 다이그래프를 쓸 수 있는 지 ":digraphs" 명령으로 꼭
	확인해야합니다.

직접 다이그래프를 정의할 수도 있습니다.  예를 들어: >

	:digraph a" ä

위 명령은 CTRL-K a" 가 ä 문자를 입력하도록 지정합니다.  문자가 아니라 10진법
숫자로 지정할 수도 있습니다.  똑같은 다이그래프를 정의하는 예입니다: >

	:digraph a" 228

다이그래프에 대한 자세한 정보는 |digraphs|를 참고하십시오.
   다이그래프 말고 키맵(keymap)을 사용해서 특수문자를 넣을 수도 있습니다.
|45.5|를 참고하십시오.

==============================================================================
*24.10*	보통 상태 명령

입력 상태에서 사용할 수 있는 명령은 그다지 많지 않습니다.  보통 상태에서는
훨씬 많은 명령들을 사용할 수 있기 때문에, <Esc>를 누르고 보통 상태로
빠져나와서 명령을 수행한 후 "i"나 "a"로 입력 상태로 돌아가는 경우가 많습니다.
   좀 더 빠른 방법이 있습니다.  CTRL-O {명령} 으로 입력 상태에서도 모든 보통
상태 명령을 사용할 수 있습니다.  예를 들어, 현재 줄 커서 이후의 내용을 모두
지우려면: >

	CTRL-O D

이 방법으로는 단 하나의 보통 상태 명령만 사용할 수 있습니다.  명령 이외에
레지스터나 횟수도 함께 지정할 수 있습니다.  좀 더 복잡한 명령의 예를 보면
다음과 같습니다: >

	CTRL-O "g3dw

세 개의 단어를 잘라내어 g 레지스터에 담습니다.

==============================================================================

다음 장: |usr_25.txt|  형식에 맞추어 편집하기

저작권: |manual-copyright| 참고  vim:tw=78:ts=8:ft=help:norl:
