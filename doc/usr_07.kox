*usr_07.txt*	Vim version 7.0. 대상   새로고침 : 2007년 9월 30일

		      VIM 사용설명서 - Bram Moolenaar 씀
				       박용운 번역

			  여러 파일 편집하기


아무리 편집할 파일이 많다고 하더라도 Vim에서 나가지 않고 편집할 수 있습니다.
작업할 파일들의 목록을 정의하고 한 파일에서 다른 파일로 이동하십시오.
한 파일에서 텍스트를 복사하고 다른 파일에 붙여넣으십시오.

|07.1|	다른 파일 편집하기
|07.2|	파일 목록
|07.3|	파일에서 파일로 이동하기
|07.4|	백업 파일
|07.5|	파일 간에 텍스트 복사하기
|07.6|	파일 보기
|07.7|	파일 이름 바꾸기
        
     다음 장 : |usr_08.kox|   창 나누기
     이전 장 : |usr_06.kox|   문법 강조 사용하기
        차례 : |usr_toc.kox|

==============================================================================
*07.1*	다른 파일 편집하기
        
지금까지는 편집하고자하는 모든 파일 각각에 대해 Vim을 시작해야만 했습니다.
더 간단한 방법이 있습니다. 다른 파일의 편집을 시작하려면 다음 명령을 사용하십시오: >

	:edit foo.txt

"foo.txt" 대신 어떤 파일 이름이든 사용할 수 있습니다.
Vim은 현재 파일을 닫고 새 파일을 열 것입니다. 그렇지만 만약 현재 파일의 바뀐 내용이 
저장되지 않았다면 Vim은 에러메시지를 보여주고 새 파일을 열지 않습니다.

        E37: 마지막으로 바꾼 다음 쓰지 않았습니다.(무시하려면 !를 사용하십시오.)~

	일러두기:	
	Vim은 각 에러 메시지의 시작부분에 에러 ID를 넣습니다.
	에러 메시지나 에러의 원인을 이해할 수 없다면 
	에러 ID를 도움말에서 찾아보십시오. 이런 경우에는: >

		:help E37

이에 대해 많은 대처방안들이 있습니다. 다음 명령을 이용해서 파일에 쓸 수 있습니다: >

	:write

또는 강제 문자(!)를 사용해서 바꾼 내용을 무시하고 새 파일을 편집할 수 있습니다: >

	:edit! foo.txt

현재 편집중인 파일에 바뀐 내용을 쓰지 않고 다른 파일을 편집하고 싶다면 파일을 감출 수 있습니다: >

	:hide edit foo.txt

바뀐 텍스트는 여전히 이전 파일에 존재하지만 볼 수는 없습니다. 
이에 대해서는 |22.4|: 버퍼 목록에서 설명할 것입니다.

==============================================================================
*07.2*	파일목록
	
일련의 파일을 편집하기 위해 Vim을 시작할 수 있습니다. 예를 들어: >

	vim one.c two.c three.c

이 명령은 Vim을 시작하고 3개의 파일을 편집할 것임을 알려줍니다.
Vim은 첫번째 파일만 보여줍니다. 첫번째 파일에 대해 작업을 완료한 이후
아래 명령을 사용해서 그 다음 파일을 편집할 수 있습니다: >

	:next

현재 파일에 바꾼 내용을 저장하지 않았다면 에러 메시지를 받을 것이고 ":next"
명령은 실행되지 않을 것입니다. 이전 장에서 언급했던 ":edit"와 같은 문제입니다. 
바꾼 내용을 버리려면:  >

	:next!

그렇지만 바뀐 내용을 저장하고 다음 파일로 이동하는 것이 일반적입니다.
이를 위해 특별한 명령이 있습니다: >

	:wnext

이것은 단일 명령 2개를 사용한 것과 같습니다: >

	:write
	:next


여기는 어디입니까?

인자목록 중 어느 파일을 편집하고 있는지를 보려면 창 제목을 보십시오.
"(2 of 3)" 과 같은 것이 보일 것입니다. 이는 3개의 파일 중 2번째 파일이라는 뜻입니다.
파일 목록을 보고 싶다면 다음의 명령을 사용하십시오: >

	:args

이것은 "arguments"의 짧은 표현입니다. 결과는 다음과 같습니다:

	one.c [two.c] three.c ~

이 파일들은 Vim을 시작할 때 인자로 준 것들입니다. 
현재 편집 중인 파일 "two.c"는 대괄호(사각 괄호)로 묶여 있습니다.


다른 인자들로 이동하기

이전 파일로 돌아가려면: >

	:previous

이 명령은 다른 방향으로 움직인다는 것을 제외하면 ":next" 명령과 같습니다.
이동하기 전, 파일에 먼저 쓰길 원할 때 사용하는 단축 명령입니다: >

	:wprevious

목록의 가장 마지막 파일로 이동하려면 : >

	:last

그리고 다시 첫번째 파일로 돌아가려면 : >

	:first

":wlast"나 ":wfirst" 명령은 없습니다!

":next"와 ":previous"에 횟수를 적용할 수 있습니다. 2파일 앞으로 이동하려면: >

	:2next


자동 쓰기

파일들을 돌아다니며 바꾼 내용이 있을 때 ":write"를 사용해야하는 것을
기억하십시오. 그렇지 않으면 에러메시지를 받습니다.
수정된 파일을 항상 쓰고 싶다면 Vim이 자동으로 쓰게 할 수 있습니다: >

	:set autowrite

쓰기 원하지 않는 파일을 편집하고 있을 때에는 다시 자동쓰기 기능을 끄십시오: >

	:set noautowrite


다른 파일 목록 편집하기

Vim을 재시작할 필요없이 파일 목록을 재정의 할 수 있습니다.
3개의 다른 파일을 편집하려면 다음 명령을 사용하십시오: >

	:args five.c six.c seven.h

혹은 쉘에서 쓰는 것처럼 와일드카드 문자를 사용할 수 있습니다: >

	:args *.txt

Vim은 목록의 첫번째 파일을 보여줄 것입니다.
현재 파일에 바뀐 내용이 있다면 먼저 파일에 쓰거나 ":args!"(! 가 추가되었습니다.)를 
사용해서 바뀐 내용을 포기합니다.


마지막 파일을 편집했었습니까?
							*arglist-quit*
파일 목록을 사용할 때 Vim은 목록에 있는 모든 파일을 편집한다고 가정합니다.
너무 일찍 종료하는 것을 방지하기 위해서 목록의 마지막 파일을 편집하지 않았을 때 다음 에러가 발생합니다:

	E173: 46 more files to edit ~

만약 정말 종료하길 원한다면 단지 다시 시도하기만 하면 됩니다.
그러면 종료될 것입니다. (그렇지만 중간에 다른 명령들을 실행했다면 되지 않습니다.)
==============================================================================
*07.3*	파일에서 파일로 이동하기

두 개의 파일 사이를 빠르게 이동하려면, CTRL-^를 누르십시오. 
(English-US 키보드에서는 ^는 6키 위에 있습니다.)
예를 들어: >

	:args one.c two.c three.c

지금 one.c에 있습니다: >

	:next

이제는 two.c에 있습니다. 여기서 CTRL-^를 사용하면 one.c로 돌아갑니다. 다시 CTRL-^를 사용하면 two.c로 돌아갑니다. 한 번 더 CTRL-^를 사용하면 one.c로 다시 돌아갑니다. 만약 지금 다음을 실행한다면: >

	:next

three.c로 이동합니다. CTRL-^ 명령은 파일 목록에서의 위치 개념을 바꾸지 않는다는 것에 유의하십시오. 파일 목록에서의 위치를 바꾸는 것은 오직 ":next"와 ":previous"만이 가능합니다.

이전에 편집했던 파일을 "alternate(교체)" 파일이라 부릅니다. Vim을 막 시작했을 때 CTRL-^가 동작하지 않는 것은 이전 파일이 없기 때문입니다.


미리 정의된 마크들

다른 파일로 건너뛴 다음에는 미리 정의된 매우 유용한 두 개의 마크를 사용할 수 있습니다: >

	`"

이것은 이전에 파일을 나갔을 때 커서가 있던 위치로 옮겨줍니다.
다른 마크는 마지막으로 바꾼 내용의 위치를 기억하고 있습니다: >

	`.

"one.txt"를 편집하고 있다고 생각해봅시다. 그 파일의 중간쯤에서 문자를 삭제하는 
"x"를 사용하십시오. 그리고 나서 "G"를 이용해 마지막 줄로 이동하고 ":w"로 파일을 
쓰십시오. 몇 개의 다른 파일들을 편집하고 ":edit one.txt"을 사용하여 "one.txt"로 
돌아가십시오. 여기서 `" 를 사용하면 파일의 마지막 줄로 이동합니다.
`. 를 사용하면 삭제했던 문자의 위치로 이동합니다. 파일의 여기저기를 돌아다니는 중에도 다른 내용을 바꾸거나 파일을 나가기 전까지 `"과 `.는 기억되어있는 위치로 이동시켜줍니다.


파일 표시

4장에서 어떻게 "mx"로 파일에 마크를 남기고 "`x"로 마크한 위치로 이동하는 것을 
설명했습니다. 이런 방법은 한 파일에서만 동작합니다. 다른 파일을 편집하고 그
파일에 마크(표시)들를 남겼다면 그 마크(표시)들은 그 파일 내에서만 유효합니다.
그러므로 각각의 파일은 그 파일에만 한정되는 자신만의 마크 모음을 가집니다.
지금까지는 마크에 소문자를 사용했습니다. 물론 대문자를 이용한 마크도 있습니다.
대문자를 이용한 마크들은 전역적이어서 어떤 파일에서든 사용할 수 있습니다.
예를 들어 "foo.txt"를 편집하고 있다고 합시다.
파일의 중간("50%")으로 가서 거기에 F 마크를 해두십시오. (foo의 F): >

	50%mF

이제 "bar.txt" 파일을 편집하고 마지막 줄에 B 마크를 해두십시오.(bar의 B): >

	GmB

여기서 "'F" 명령을 사용해서 foo.txt의 중간으로 이동할 수 있습니다. 또는 다른 파일을 편집하다가도 "'B"를 입력하면 다시 bar.txt의 끝으로 이동합니다. 파일 마크들은 어딘가 다른 곳으로 옮겨지기 전까지 기억됩니다. 그러므로 마크를 할 수 있고 편집 중에 시간이 지나도 마크를 해둔 곳으로 이동할 수 있습니다.


마크에 사용하는 문자와 그것이 어디에 있는지에 대해 간단한 연관성을 생각하는 것은 꽤 유용합니다. 예를 들어 H마크는 헤더 파일에 M은 Makefile 그리고 C는 C 코드 파일에 사용하십시오.

특정 마크의 위치를 보려면 ":marks" 명령에 인자를 주십시오: >
	:marks M

물론 여러 개의 인자를 줄 수도 있습니다: >
	:marks MCP

Don't forget that you can use CTRL-O and CTRL-I to jump to older and newer
positions without placing marks there.
그곳에 마크가 없더라도 이전이나 새로운 위치로 이동하기 위해서 CTRL-O와 CTRL-I를 사용할 수 있다는 것을 잊지 마십시오.

==============================================================================
*07.4*	백업파일들

일반적으로 Vim은 백업 파일을 만들지 않습니다. 백업 파일이 필요하다면 다음 명령을 실행하십시오: >

	:set backup

백업 파일의 이름은 원본 파일 이름의 마지막에 ~를 추가한 것입니다. 
예를 들어 data.txt이라는 이름을 가진 파일이 있다면 백업 파일의 이름은 data.txt~입니다.
백업파일의 끝에 ~가 붙는 것이 싫다면 확장자를 바꿀 수 있습니다: >

	:set backupext=.bak

이제 data.txt~ 대신에 data.txt.bak를 사용할 것입니다.
다른 옵션은 'backupdir'입니다. 이 옵션은 백업파일을 어디에 쓸 것인지를 지정합니다. 
기본적으로 원본 파일과 같은 디렉토리에 백업파일을 쓰는데 대체로 맞습니다.

        일러두기:
	'backup' 옵션이 설정되어 있지 않아도  'writebackup'이 설정되어 있다면 Vim은 여전히 백업파일을 만들 것입니다.
	그러나 파일에 쓰는 것이 성공적 완료되는 즉시 삭제됩니다.
	이 기능은 어떤 이유(디스크가 꽉 찬 것은 가장 흔한 이유입니다; 흔하지는 않지만 번개에 맞는 경우도 있습니다.)에서든 쓰기에 실패했을 때 원본 파일의 소실에 대비하기 위한 것입니다.


원본 파일 보존하기

소스 파일을 편집한다면 내용을 바꾸기 전에 파일을 보존하고 싶을 것입니다. 그렇지만 백업 파일은 파일에 쓸 때마다 덮어쓰게 됩니다. 처음의 파일이 아닌 단지 이전 버전이 유지되는 것입니다. Vim이 원본 파일을 보존하게 하려면 'patchmode' 옵션을 설정하십시오. 'patchmode'옵션은 바뀐 파일의 첫번째 백업에 사용되는 확장자를 지정합니다.
이렇게 하십시오 : >

	:set patchmode=.orig

data.txt파일을 처음으로 편집할 때 파일을 바꾸고 쓰면, Vim은 바뀌지 않은 파일의 복사본을 "data.txt.orig"라는 이름으로 유지할 것입니다. 파일을 좀 더 바꾼다면 Vim은 "data.txt.orig"가 이미 존재한다는 것을 알려주고 그냥 놔둘 것입니다. 이후의 백업파일들은 "data.txt~"으로 불려집니다. (혹은 'backupext'로 설정해 놓은 것으로 불려집니다.)
'patchmode'를 비워둔다면 (이것이 기본입니다.), 원본 파일은 유지되지 않을 것입니다.

==============================================================================
*07.5*	파일 사이에 텍스트 복사하기

여기에서는 하나의 파일에서 다른 파일로 텍스트를 어떻게 복사하는지 설명하겠습니다.
간단한 예제로 시작해봅시다. 복사하고자 하는 텍스트를 포함하고 있는 파일을 편집하십시오. 커서를 복사하려는 텍스트의 첫부분에 놓고 "v"를 눌러서 visual 모드를 시작하십시오.
텍스트의 마지막 부분에 커서를 이동시키고 "y"를 누르십시오. 이렇게 해서 선택된 텍스트를 뽑아냅니다.(복사합니다.) 위의 내용대로 하려면 다음과 같이 하십시오: >

	:edit thisfile
	/This
	vjjjj$y

이제 텍스트를 붙여넣길 원하는 파일을 편집하십시오. 텍스트가 뒤에 오길 원하는 문자에 커서를 옮기신 다음 "p"를 사용해서 거기에 텍스트를 붙여넣으십시오: >

	:edit otherfile
	/There
	p

물론 텍스트를 뽑아내는 수많은 다른 명령을 사용할 수 있습니다. 예를 들면 몇 줄을 선택하기 위해서 "V"로 비주얼 모드를 시작한다거나 CTRL-V를 사용해서 직사각형 영역을 선택할 수도 있고 "Y"를 사용해서 한 줄을 복사할 수도, "yaw"를 사용해서 한 단어를 복사할 수도 있습니다.

"p" 명령은 커서의 뒤에 텍스트를 넣습니다. "P"를 사용하면 커서의 앞에 텍스트를 넣습니다. Vim은 복사한 줄이나 블록을 기억하고 있고 그것을 위의 방법으로 붙여넣는다는 것에 유의하십시오.


레지스터 사용하기

여러 텍스트 조각을 한 파일에서 다른 파일로 복사하고 싶을 때, 파일 사이를 이동하고
대상 파일에 쓰는데 많은 시간이 걸립니다. 이것을 피하기 위해, 각 텍스트 조각을 각각의 레지스터에 복사합니다. 레지스터는 Vim이 텍스트를 저장하는 공간입니다.
여기에서는 a에서 z까지 이름붙인 레지스터를 사용할 것입니다.(나중에 다른 것들도 찾아낼 것입니다.) 
f 레지스터에 문장을 복사해봅시다.(First의 f) :>

	"fyas

이전처럼 "yas" 명령은 문장을 뽑아냅니다. "f는 Vim에게 텍스트를 f레지스터에 위치시킬 것을 지시합니다. 이것은 반드시 복사하는 명령 앞에 와야합니다.
이제 3개의 줄을 l 레지스터에 복사하십시오(line의 l) : >

	"l3Y

"l 앞에 개수가 있을 수 있습니다. 텍스트 블록을 b(block의 b) 레지스터에 복사하려면: >

	CTRL-Vjjww"by

"y" 명령 바로 앞에 레지스터 지시자 "b가 있다는 것에 주의하십시오.
필수입니다. "w" 명령 이전에 그것을 넣으면 동작하지 않습니다.
이제 3개의 텍스트 조각을 f, l, b 레지스터에 가지고 있습니다.
다른 파일들을 편집하고 돌아니다가 원하는 위치에 텍스트를 넣으십시오: >

	"fp

여기서도 "p" 명령 앞에 레지스터 지시자 "f 가 옵니다.
어떤 명령에도 레지스터들을 넣을 수 있습니다. 그리고 다른 것을 복사해넣기 전에는 그 텍스트는 레지스터 안에 있습니다.
그래서 레지스터에 있는 텍스트를 원하는대로 붙여 넣을 수 있습니다. 


텍스트를 지울 때도 레지스터를 명시할 수 있습니다. 
이를 몇 개의 텍스트 조각을 옮기는데 사용하십시오. 예를 들어, 한 단어를 지우고 그것을 w 레지스터에 쓰려면: >

	"wdaw

여기서도 삭제 명령 "d" 앞에 레지스터 지시자가 옵니다.


파일에 추가하기

한 파일에 있는 텍스트 줄들을 선택할 때 다음의 명령을 사용할 수 있습니다: >

	:write >> logfile

이렇게 하면 "logfile"의 끝에 현재 파일의 텍스트를 씁니다. 그래서 추가라고 합니다.
라인을 복사하고 로그파일을 열어서 거기에 붙여 넣어야 하는 것을 피할 수 있습니다.
그렇게 2단계를 절약할 수 있습니다. 그렇지만 파일을 끝부분에만 추가할 수 있습니다.
몇 줄만 추가하려고 한다면 ":write"를 치기 전에 비주얼 모드에서 추가할 줄을 선택하십시오.
10장에서 줄의 범위를 선택하는 다른 방법들을 배울 것입니다.

*07.6*	파일 보기

가끔 쓰지 않고 파일 내용만을 보고 싶을 때가 있습니다. 
그렇지만 그런 경우에 생각없이 ":w"를 치고 원본 파일에 덮어쓸 위험이 있습니다.
이런 위험을 피하기 위해 파일을 읽기 전용으로 편집할 수 있습니다.
읽기 전용 모드로 Vim을 시작하려면 다음 명령을 사용하십시오 : >

	vim -R file

Unix에서 다음 명령도 같은 역할을 합니다: >

	view file

이제 "file"을 읽기 전용 모드로 편집하고 있습니다. ":w"를 사용하려고하면
에러메시지를 받을 것이고 파일에는 써지지는 않습니다.
파일 내용을 바꾸려고 하면 Vim은 다음과 같이 경고할 것입니다.

        W10: 경고: 읽기 전용 파일을 변경하고 있습니다.~

경고에도 불구하고 파일은 바뀔 것입니다. 이런 사실을, 예를 들어, 파일을 읽기 좋게 하기 위해 형식화할 때 고려할 수 있습니다.
파일이 읽기 전용인 것을 잊고 파일을 바꾸었다고 해도 파일에 쓸 수 있습니다.
강제로 쓰려면 쓰기 명령에 !를 붙이십시오.
정말로 파일을 변경할 수 없게 하고 싶다면 다음과 같이 하십시오: >

	vim -M file

이제 텍스트를 바꾸려고 하면 실패할 것입니다. 예를 들면, 도움말 파일이 이렇게 되어 있습니다. 만약 변경하려 한다면 다음 에러메시지를 받을 것입니다.

        E21: 변경이 불가능합니다. 'modifiable'이 꺼져있습니다.~

Vim이 관찰모드로 동작하게 설정하려면 -M 인자를 사용할 수 있습니다.
의도적으로 한 것이긴 하지만 다음 명령들로 보호를 제거할 수 있습니다: >

	:set modifiable
	:set write

==============================================================================
*07.7*	파일 이름 바꾸기

새로운 파일의 편집을 시작하는 현명한 방법은 원하는 내용을 대부분 포함하고 있는 기존 파일을 사용하는 것입니다.
예를 들어, 파일을 옮기는 프로그램을 새로 작성한다고 합시다. 
이미 파일을 복사하는 프로그램이 있다고 가정하고 이렇게 시작합시다.: >

	:edit copy.c

원하지 않는 내용은 삭제할 수 있습니다. 그 파일을 새 이름으로 저장하고 싶을 때 "saveas" 명령을 사용합니다: >

	:saveas move.c

Vim은 주어진 이름(move.c)으로 파일을 쓰고 그 파일(move.c)을 편집합니다. 
그러므로 다음에 ":write"를 사용하면 "move.c"에 쓸 것입니다. "copy.c"는 바뀌지 않습니다.
편집 중에 파일을 쓰지 않고 이름만 바꾸고 싶다면 다음 명령을 사용할 수 있습니다: >

	:file move.c

Vim은 파일에 "편집되지 않음"이라고 표시할 것입니다. 
이것은 이 파일이 편집을 시작했던 파일이 아니라는 것을 Vim이 알고 있다는 것을 의미합니다.
그 파일을 쓰려고 하면 다음 메시지를 받게 됩니다.

	E13: 파일이 존재합니다.(무시하려면 !를 사용하십시오.)~

이것은 실수로 다른 파일에 중복해서 쓰는 것을 막아줍니다.
==============================================================================

다음 장: |usr_08.txt|	창 나누기
저작권: |manual-copyright|참고  vim:tw=78:ts=8:ft=help:norl:
